package admin

import (
	"fmt"
	"strconv"
	"time"
	"github.com/TheLab-ms/conway/modules/bootstrap"
)

func secretPlaceholder(hasValue bool) string {
	if hasValue {
		return "(secret is set - leave blank to keep)"
	}
	return "(not set)"
}

func secretHelpText(hasValue bool) string {
	if hasValue {
		return "Leave blank to keep the current value."
	}
	return ""
}

type configSection struct {
	Name string
	Path string
}

var configSections = []*configSection{
	{Name: "Waiver", Path: "/admin/config/waiver"},
	{Name: "Discord", Path: "/admin/config/discord"},
	{Name: "Stripe", Path: "/admin/config/stripe"},
	{Name: "Bambu", Path: "/admin/config/bambu"},
}

templ renderConfigPage(tabs []*navbarTab, activeSection string, content templ.Component) {
	@bootstrap.View() {
		@adminNav(tabs)
		<div class="container my-5">
			<div class="row">
				<div class="col-md-3">
					<div class="card">
						<div class="card-header">
							<h5 class="mb-0">Configuration</h5>
						</div>
						<div class="list-group list-group-flush">
							for _, section := range configSections {
								if section.Name == activeSection {
									<a href={ templ.SafeURL(section.Path) } class="list-group-item list-group-item-action active">{ section.Name }</a>
								} else {
									<a href={ templ.SafeURL(section.Path) } class="list-group-item list-group-item-action">{ section.Name }</a>
								}
							}
						</div>
					</div>
				</div>
				<div class="col-md-9">
					@content
				</div>
			</div>
		</div>
	}
}

type waiverConfigData struct {
	Version int
	Content string
	Saved   bool
}

templ renderWaiverConfigContent(data *waiverConfigData) {
	<div class="card">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Waiver Content</h5>
			<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Waiver content saved successfully. A new version has been created.
				</div>
			}
			<form method="post">
				<div class="mb-3">
					<label for="content" class="form-label">Waiver Content (Markdown)</label>
					<textarea class="form-control font-monospace" id="content" name="content" rows="20" required>{ data.Content }</textarea>
					<div class="form-text">
						<strong>Syntax:</strong>
						<ul class="mb-0 mt-1">
							<li><code># Title</code> - Sets the page title (first one wins)</li>
							<li>Regular text becomes paragraphs (separate with blank lines)</li>
							<li><code>- [ ] Checkbox text</code> - Creates a required checkbox</li>
						</ul>
					</div>
				</div>
				<div class="d-flex justify-content-between align-items-center">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version.</span>
				</div>
			</form>
		</div>
	</div>
}

type discordConfigData struct {
	Version            int
	ClientID           string
	HasClientSecret    bool
	HasBotToken        bool
	GuildID            string
	RoleID             string
	HasPrintWebhookURL bool
	SyncIntervalHours  int
	Saved              bool
	Error              string

	// Status fields
	TotalLinkedMembers int
	PendingSyncs       int
	RecentEvents       []*discordEvent
}

type discordEvent struct {
	Created       time.Time
	EventType     string
	DiscordUserID string
	Success       bool
	Details       string
	MemberName    string
}

templ renderDiscordConfigContent(data *discordConfigData, selfURL string) {
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Discord Integration</h5>
			if data.Version > 0 {
				<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
			}
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Discord configuration saved successfully.
				</div>
			}
			if data.Error != "" {
				<div class="alert alert-danger" role="alert">
					{ data.Error }
				</div>
			}
			<div class="alert alert-info" role="alert">
				<strong>How Discord Integration Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Account Linking:</strong> Members can link their Discord accounts via OAuth2. This stores their Discord user ID, email, and avatar.</li>
					<li><strong>Role Sync:</strong> A background worker automatically assigns/removes a Discord role based on payment status. Paying members get the role; when payment lapses, it's removed.</li>
					<li><strong>Notifications:</strong> Webhook messages (e.g., 3D printer completion) are sent to configured Discord channels.</li>
				</ul>
			</div>
			<form method="post">
				<h6 class="text-muted border-bottom pb-2 mb-3">OAuth2 Configuration</h6>
				<p class="text-muted small mb-3">
					These settings enable members to link their Discord accounts.
					Create an OAuth2 application at the
					<a href="https://discord.com/developers/applications" target="_blank" rel="noopener">Discord Developer Portal</a>.
					Set the redirect URL to: <code>{ selfURL }/discord/callback</code>
				</p>
				<div class="mb-3">
					<label for="client_id" class="form-label">Client ID</label>
					<input type="text" class="form-control font-monospace" id="client_id" name="client_id" value={ data.ClientID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">The Application ID from Discord Developer Portal.</div>
				</div>
				<div class="mb-3">
					<label for="client_secret" class="form-label">Client Secret</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="client_secret" name="client_secret" placeholder={ secretPlaceholder(data.HasClientSecret) }/>
					</div>
					<div class="form-text">The OAuth2 Client Secret. Keep this confidential. { secretHelpText(data.HasClientSecret) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Bot Configuration</h6>
				<p class="text-muted small mb-3">
					The bot enables Conway to manage Discord roles based on payment status.
					Create a bot in your Discord application and invite it to your server with the <code>Manage Roles</code> permission.
					The bot's role must be positioned <strong>above</strong> the member role in Discord's role hierarchy.
				</p>
				<div class="mb-3">
					<label for="bot_token" class="form-label">Bot Token</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="bot_token" name="bot_token" placeholder={ secretPlaceholder(data.HasBotToken) }/>
					</div>
					<div class="form-text">The bot token from Discord Developer Portal. Required for role sync. { secretHelpText(data.HasBotToken) }</div>
				</div>
				<div class="mb-3">
					<label for="guild_id" class="form-label">Server (Guild) ID</label>
					<input type="text" class="form-control font-monospace" id="guild_id" name="guild_id" value={ data.GuildID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">Right-click your server name in Discord (with Developer Mode enabled) and select "Copy Server ID".</div>
				</div>
				<div class="mb-3">
					<label for="role_id" class="form-label">Member Role ID</label>
					<input type="text" class="form-control font-monospace" id="role_id" name="role_id" value={ data.RoleID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">The role to assign to paying members. Right-click the role in Server Settings &gt; Roles and select "Copy Role ID".</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Notifications</h6>
				<p class="text-muted small mb-3">
					Configure webhooks for Discord notifications.
					Create a webhook in Discord: Channel Settings &gt; Integrations &gt; Webhooks.
				</p>
				<div class="mb-3">
					<label for="print_webhook_url" class="form-label">3D Print Notification Webhook URL</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="print_webhook_url" name="print_webhook_url" placeholder={ secretPlaceholder(data.HasPrintWebhookURL) }/>
					</div>
					<div class="form-text">Webhook URL for 3D printer completion and failure notifications. { secretHelpText(data.HasPrintWebhookURL) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Sync Settings</h6>
				<div class="mb-3">
					<label for="sync_interval_hours" class="form-label">Full Reconciliation Interval (hours)</label>
					<input type="number" class="form-control" id="sync_interval_hours" name="sync_interval_hours" value={ strconv.Itoa(data.SyncIntervalHours) } min="1" max="168"/>
					<div class="form-text">How often to fully reconcile all Discord role assignments. Default: 24 hours.</div>
				</div>
				<div class="d-flex justify-content-between align-items-center mt-4">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version for audit purposes.</span>
				</div>
			</form>
		</div>
	</div>
	<!-- Status Dashboard -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Status</h5>
		</div>
		<div class="card-body">
			<div class="row text-center">
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.TotalLinkedMembers) }</h3>
					<p class="text-muted mb-0">Linked Accounts</p>
				</div>
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.PendingSyncs) }</h3>
					<p class="text-muted mb-0">Pending Syncs</p>
				</div>
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.SyncIntervalHours) }h</h3>
					<p class="text-muted mb-0">Sync Interval</p>
				</div>
			</div>
		</div>
	</div>
	<!-- Metrics Chart -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Request Metrics (Last 24 Hours)</h5>
		</div>
		<div class="card-body">
			<div style="position: relative; height: 280px;">
				<canvas id="discord-metrics-chart"></canvas>
			</div>
			<p class="text-muted small mt-2 mb-0">Events are aggregated in 15-minute intervals. Data retained for 24 hours.</p>
		</div>
	</div>
	<!-- Recent Events -->
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Recent Events</h5>
			<span class="badge bg-secondary">{ strconv.Itoa(len(data.RecentEvents)) }</span>
		</div>
		if len(data.RecentEvents) > 0 {
			<div class="card-body p-0">
				<div class="table-responsive">
					<table class="table table-hover table-sm mb-0">
						<thead class="table-light">
							<tr>
								<th>Time</th>
								<th>Type</th>
								<th>Status</th>
								<th>Member</th>
								<th>Details</th>
							</tr>
						</thead>
						<tbody>
							for _, event := range data.RecentEvents {
								<tr>
									<td class="text-nowrap">{ formatEventTime(event.Created) }</td>
									<td><span class="badge bg-secondary">{ event.EventType }</span></td>
									<td>
										if event.Success {
											<span class="text-success">&#10003;</span>
										} else {
											<span class="text-danger">&#10007;</span>
										}
									</td>
									<td>{ event.MemberName }</td>
									<td class="text-truncate" style="max-width: 300px;" title={ event.Details }>{ event.Details }</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		} else {
			<div class="card-body">
				<p class="text-muted mb-0">No events recorded yet. Events will appear as Discord operations occur.</p>
			</div>
		}
	</div>
	<!-- Chart.js initialization -->
	<script src="/static/chartjs/chart.umd.min.js"></script>
	<script src="/static/chartjs/chartjs-adapter-date-fns.bundle.min.js"></script>
	<script>
		document.addEventListener('DOMContentLoaded', async function() {
			const canvas = document.getElementById('discord-metrics-chart');
			if (!canvas) return;

			const seriesConfig = [
				{ name: 'sync-successes', label: 'Sync Successes', color: 'rgb(25, 135, 84)' },
				{ name: 'sync-errors', label: 'Sync Errors', color: 'rgb(220, 53, 69)' },
				{ name: 'api-requests', label: 'Total Requests', color: 'rgb(13, 110, 253)' }
			];

			const datasets = [];
			for (const cfg of seriesConfig) {
				try {
					const resp = await fetch('/admin/discord-chart?series=' + encodeURIComponent(cfg.name) + '&window=24h');
					const data = await resp.json();
					if (data && data.length > 0) {
						datasets.push({
							label: cfg.label,
							data: data.map(p => ({ x: p.t * 1000, y: p.v })),
							borderColor: cfg.color,
							backgroundColor: cfg.color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
							borderWidth: 2,
							tension: 0.3,
							fill: false,
							pointRadius: 2
						});
					}
				} catch (e) {
					console.error('Failed to fetch', cfg.name, e);
				}
			}

			if (datasets.length === 0) {
				canvas.parentElement.innerHTML = '<p class="text-muted text-center">No metrics data available yet.</p>';
				return;
			}

			new Chart(canvas, {
				type: 'line',
				data: { datasets },
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						x: { type: 'time', time: { unit: 'hour' } },
						y: { beginAtZero: true }
					},
					plugins: {
						legend: { display: true, position: 'top' }
					}
				}
			});
		});
	</script>
}

type stripeConfigData struct {
	Version             int
	HasAPIKey           bool
	HasWebhookKey       bool
	Saved               bool
	Error               string

	// Status fields
	ActiveSubscriptions int
	TotalCustomers      int
	RecentEvents        []*stripeEvent
}

type stripeEvent struct {
	Created          time.Time
	EventType        string
	StripeCustomerID string
	Success          bool
	Details          string
	MemberName       string
}

templ renderStripeConfigContent(data *stripeConfigData, selfURL string) {
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Stripe Integration</h5>
			if data.Version > 0 {
				<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
			}
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Stripe configuration saved successfully.
				</div>
			}
			if data.Error != "" {
				<div class="alert alert-danger" role="alert">
					{ data.Error }
				</div>
			}
			<div class="alert alert-info" role="alert">
				<strong>How Stripe Integration Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Subscriptions:</strong> Members pay for membership via Stripe Checkout. Conway receives webhooks when subscription status changes.</li>
					<li><strong>Billing Portal:</strong> Active members can manage their subscription (update payment method, cancel) via Stripe's billing portal.</li>
					<li><strong>Discounts:</strong> Coupons configured in Stripe with matching <code>discountTypes</code> metadata are automatically applied.</li>
				</ul>
			</div>
			<form method="post">
				<h6 class="text-muted border-bottom pb-2 mb-3">API Configuration</h6>
				<p class="text-muted small mb-3">
					Get your API keys from the
					<a href="https://dashboard.stripe.com/apikeys" target="_blank" rel="noopener">Stripe Dashboard</a>.
					Use test keys for development and live keys for production.
				</p>
				<div class="mb-3">
					<label for="api_key" class="form-label">Secret Key</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="api_key" name="api_key" placeholder={ secretPlaceholder(data.HasAPIKey) }/>
					</div>
					<div class="form-text">The API secret key (starts with <code>sk_test_</code> or <code>sk_live_</code>). { secretHelpText(data.HasAPIKey) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Webhook Configuration</h6>
				<p class="text-muted small mb-3">
					Create a webhook endpoint in the
					<a href="https://dashboard.stripe.com/webhooks" target="_blank" rel="noopener">Stripe Dashboard</a>.
					Set the endpoint URL to: <code>{ selfURL }/webhooks/stripe</code>
					<br/>Subscribe to events: <code>customer.subscription.created</code>, <code>customer.subscription.updated</code>, <code>customer.subscription.deleted</code>
				</p>
				<div class="mb-3">
					<label for="webhook_key" class="form-label">Webhook Signing Secret</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="webhook_key" name="webhook_key" placeholder={ secretPlaceholder(data.HasWebhookKey) }/>
					</div>
					<div class="form-text">The webhook signing secret (starts with <code>whsec_</code>). Used to verify webhook authenticity. { secretHelpText(data.HasWebhookKey) }</div>
				</div>
				<div class="d-flex justify-content-between align-items-center mt-4">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version for audit purposes.</span>
				</div>
			</form>
		</div>
	</div>
	<!-- Status Dashboard -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Status</h5>
		</div>
		<div class="card-body">
			<div class="row text-center">
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.ActiveSubscriptions) }</h3>
					<p class="text-muted mb-0">Active Subscriptions</p>
				</div>
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.TotalCustomers) }</h3>
					<p class="text-muted mb-0">Total Customers</p>
				</div>
			</div>
		</div>
	</div>
	<!-- Metrics Chart -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">API Metrics (Last 24 Hours)</h5>
		</div>
		<div class="card-body">
			<div style="position: relative; height: 280px;">
				<canvas id="stripe-metrics-chart"></canvas>
			</div>
			<p class="text-muted small mt-2 mb-0">Events are aggregated in 15-minute intervals. Data retained for 24 hours.</p>
		</div>
	</div>
	<!-- Recent Events -->
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Recent Events</h5>
			<span class="badge bg-secondary">{ strconv.Itoa(len(data.RecentEvents)) }</span>
		</div>
		if len(data.RecentEvents) > 0 {
			<div class="card-body p-0">
				<div class="table-responsive">
					<table class="table table-hover table-sm mb-0">
						<thead class="table-light">
							<tr>
								<th>Time</th>
								<th>Type</th>
								<th>Status</th>
								<th>Member</th>
								<th>Details</th>
							</tr>
						</thead>
						<tbody>
							for _, event := range data.RecentEvents {
								<tr>
									<td class="text-nowrap">{ formatEventTime(event.Created) }</td>
									<td><span class="badge bg-secondary">{ event.EventType }</span></td>
									<td>
										if event.Success {
											<span class="text-success">&#10003;</span>
										} else {
											<span class="text-danger">&#10007;</span>
										}
									</td>
									<td>{ event.MemberName }</td>
									<td class="text-truncate" style="max-width: 300px;" title={ event.Details }>{ event.Details }</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		} else {
			<div class="card-body">
				<p class="text-muted mb-0">No events recorded yet. Events will appear as Stripe operations occur.</p>
			</div>
		}
	</div>
	<!-- Chart.js initialization -->
	<script src="/static/chartjs/chart.umd.min.js"></script>
	<script src="/static/chartjs/chartjs-adapter-date-fns.bundle.min.js"></script>
	<script>
		document.addEventListener('DOMContentLoaded', async function() {
			const canvas = document.getElementById('stripe-metrics-chart');
			if (!canvas) return;

			const seriesConfig = [
				{ name: 'successes', label: 'Successes', color: 'rgb(25, 135, 84)' },
				{ name: 'errors', label: 'Errors', color: 'rgb(220, 53, 69)' },
				{ name: 'api-requests', label: 'Total Requests', color: 'rgb(13, 110, 253)' }
			];

			const datasets = [];
			for (const cfg of seriesConfig) {
				try {
					const resp = await fetch('/admin/stripe-chart?series=' + encodeURIComponent(cfg.name) + '&window=24h');
					const data = await resp.json();
					if (data && data.length > 0) {
						datasets.push({
							label: cfg.label,
							data: data.map(p => ({ x: p.t * 1000, y: p.v })),
							borderColor: cfg.color,
							backgroundColor: cfg.color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
							borderWidth: 2,
							tension: 0.3,
							fill: false,
							pointRadius: 2
						});
					}
				} catch (e) {
					console.error('Failed to fetch', cfg.name, e);
				}
			}

			if (datasets.length === 0) {
				canvas.parentElement.innerHTML = '<p class="text-muted text-center">No metrics data available yet.</p>';
				return;
			}

			new Chart(canvas, {
				type: 'line',
				data: { datasets },
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						x: { type: 'time', time: { unit: 'hour' } },
						y: { beginAtZero: true }
					},
					plugins: {
						legend: { display: true, position: 'top' }
					}
				}
			});
		});
	</script>
}

type bambuPrinterFormData struct {
	Index         int
	Name          string
	Host          string
	HasAccessCode bool
	SerialNumber  string
}

type bambuConfigData struct {
	Version          int
	Printers         []*bambuPrinterFormData
	PollIntervalSecs int
	Saved            bool
	Error            string

	// Status fields
	ConfiguredPrinters int
	RecentEvents       []*bambuEvent
}

type bambuEvent struct {
	Created       time.Time
	EventType     string
	PrinterName   string
	PrinterSerial string
	Success       bool
	Details       string
}

templ renderPrinterCard(printer *bambuPrinterFormData, index int) {
	<div class="card mb-3 printer-card" data-printer-index={ strconv.Itoa(index) }>
		<div class="card-header d-flex justify-content-between align-items-center py-2">
			<span class="fw-semibold printer-name-display">
				if printer.Name != "" {
					{ printer.Name }
				} else {
					New Printer
				}
			</span>
			<button type="button" class="btn btn-sm btn-outline-danger delete-printer-btn" onclick="confirmDeletePrinter(this)">
				Delete
			</button>
		</div>
		<div class="card-body">
			<div class="row g-3">
				<div class="col-md-6">
					<label class="form-label">Name</label>
					<input type="text" class="form-control printer-name-input" name={ fmt.Sprintf("printer[%d][name]", index) } value={ printer.Name } placeholder="e.g., Lab Printer 1" required/>
				</div>
				<div class="col-md-6">
					<label class="form-label">Host/IP Address</label>
					<input type="text" class="form-control" name={ fmt.Sprintf("printer[%d][host]", index) } value={ printer.Host } placeholder="e.g., 192.168.1.100" required/>
				</div>
				<div class="col-md-6">
					<label class="form-label">Access Code</label>
					<input type="password" class="form-control font-monospace" name={ fmt.Sprintf("printer[%d][access_code]", index) } placeholder={ secretPlaceholder(printer.HasAccessCode) }/>
					<div class="form-text">{ secretHelpText(printer.HasAccessCode) }</div>
				</div>
				<div class="col-md-6">
					<label class="form-label">Serial Number</label>
					<input type="text" class="form-control font-monospace" name={ fmt.Sprintf("printer[%d][serial_number]", index) } value={ printer.SerialNumber } placeholder="e.g., 01P00A123456789" required/>
				</div>
			</div>
		</div>
		<!-- Delete confirmation (hidden by default) -->
		<div class="card-footer bg-danger-subtle text-danger d-none delete-confirm">
			<span>Are you sure you want to remove this printer?</span>
			<button type="button" class="btn btn-sm btn-danger ms-2" onclick="deletePrinter(this)">
				Confirm Delete
			</button>
			<button type="button" class="btn btn-sm btn-secondary ms-1" onclick="cancelDeletePrinter(this)">
				Cancel
			</button>
		</div>
	</div>
}

templ renderBambuConfigContent(data *bambuConfigData) {
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Bambu 3D Printer Integration</h5>
			if data.Version > 0 {
				<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
			}
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Bambu configuration saved successfully. Printer connections will be reloaded on next poll.
				</div>
			}
			if data.Error != "" {
				<div class="alert alert-danger" role="alert">
					{ data.Error }
				</div>
			}
			<div class="alert alert-info" role="alert">
				<strong>How Bambu Integration Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Status Monitoring:</strong> Conway polls each Bambu printer via MQTT to display real-time status, progress, and camera feeds.</li>
					<li><strong>Notifications:</strong> Print completion and failure notifications are sent to Discord (configure the webhook URL in Discord settings).</li>
					<li><strong>User Mentions:</strong> Include <code>{ "@username" }</code> in your plate name in Bambu Studio to get mentioned in Discord notifications.</li>
				</ul>
			</div>
			<form method="post" id="bambu-config-form">
				<h6 class="text-muted border-bottom pb-2 mb-3">Printers</h6>
				<p class="text-muted small mb-3">
					Configure your Bambu printers. Each printer needs a name, host (IP address), access code, and serial number.
					Find the access code in Bambu Studio: Printer &gt; Device &gt; Local Connection.
				</p>
				<!-- Printer Cards Container -->
				<div id="printers-container" data-next-index={ strconv.Itoa(len(data.Printers)) }>
					for i, printer := range data.Printers {
						@renderPrinterCard(printer, i)
					}
				</div>
				<!-- Add Printer Button -->
				<button type="button" class="btn btn-outline-primary mb-4" onclick="addPrinter()">
					+ Add Printer
				</button>
				<!-- Hidden template for new printers (JavaScript will clone this) -->
				<template id="printer-card-template">
					@renderPrinterCard(&bambuPrinterFormData{Index: -1}, -1)
				</template>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Polling Settings</h6>
				<div class="mb-3">
					<label for="poll_interval_seconds" class="form-label">Poll Interval (seconds)</label>
					<input type="number" class="form-control" id="poll_interval_seconds" name="poll_interval_seconds" value={ strconv.Itoa(data.PollIntervalSecs) } min="1" max="60"/>
					<div class="form-text">How often to poll printers for status updates. Default: 5 seconds.</div>
				</div>
				<div class="d-flex justify-content-between align-items-center mt-4">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version for audit purposes.</span>
				</div>
			</form>
			<!-- JavaScript for dynamic printer management -->
			<script>
				var printerIndex = parseInt(document.getElementById('printers-container').getAttribute('data-next-index')) || 0;

				function addPrinter() {
					var template = document.getElementById('printer-card-template');
					var clone = template.content.cloneNode(true);
					var card = clone.querySelector('.printer-card');

					// Update the index in data attribute and all input names
					card.setAttribute('data-printer-index', printerIndex);
					card.querySelectorAll('input').forEach(function(input) {
						var name = input.getAttribute('name');
						if (name) {
							input.setAttribute('name', name.replace('[-1]', '[' + printerIndex + ']'));
						}
						// Clear placeholder for access code on new printers
						if (name && name.includes('access_code')) {
							input.setAttribute('placeholder', '(required for new printers)');
						}
					});

					// Add name change listener
					var nameInput = card.querySelector('.printer-name-input');
					if (nameInput) {
						nameInput.addEventListener('input', function() {
							var header = card.querySelector('.card-header .printer-name-display');
							if (header) {
								header.textContent = this.value || 'New Printer';
							}
						});
					}

					document.getElementById('printers-container').appendChild(clone);
					printerIndex++;

					// Focus the first input
					var firstInput = document.getElementById('printers-container').lastElementChild.querySelector('input');
					if (firstInput) {
						firstInput.focus();
					}
				}

				function confirmDeletePrinter(btn) {
					var card = btn.closest('.printer-card');
					var confirmDiv = card.querySelector('.delete-confirm');
					confirmDiv.classList.remove('d-none');
					btn.classList.add('d-none');
				}

				function cancelDeletePrinter(btn) {
					var card = btn.closest('.printer-card');
					var confirmDiv = card.querySelector('.delete-confirm');
					var deleteBtn = card.querySelector('.delete-printer-btn');
					confirmDiv.classList.add('d-none');
					deleteBtn.classList.remove('d-none');
				}

				function deletePrinter(btn) {
					var card = btn.closest('.printer-card');
					card.remove();
				}

				// Update card headers when name changes (for existing printers)
				document.addEventListener('DOMContentLoaded', function() {
					document.querySelectorAll('.printer-name-input').forEach(function(input) {
						input.addEventListener('input', function() {
							var card = this.closest('.printer-card');
							var header = card.querySelector('.card-header .printer-name-display');
							if (header) {
								header.textContent = this.value || 'New Printer';
							}
						});
					});
				});
			</script>
		</div>
	</div>
	<!-- Status Dashboard -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Status</h5>
		</div>
		<div class="card-body">
			<div class="row text-center">
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.ConfiguredPrinters) }</h3>
					<p class="text-muted mb-0">Configured Printers</p>
				</div>
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.PollIntervalSecs) }s</h3>
					<p class="text-muted mb-0">Poll Interval</p>
				</div>
			</div>
		</div>
	</div>
	<!-- Metrics Chart -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">API Metrics (Last 24 Hours)</h5>
		</div>
		<div class="card-body">
			<div style="position: relative; height: 280px;">
				<canvas id="bambu-metrics-chart"></canvas>
			</div>
			<p class="text-muted small mt-2 mb-0">Events are aggregated in 15-minute intervals. Data retained for 24 hours.</p>
		</div>
	</div>
	<!-- Recent Events -->
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Recent Events</h5>
			<span class="badge bg-secondary">{ strconv.Itoa(len(data.RecentEvents)) }</span>
		</div>
		if len(data.RecentEvents) > 0 {
			<div class="card-body p-0">
				<div class="table-responsive">
					<table class="table table-hover table-sm mb-0">
						<thead class="table-light">
							<tr>
								<th>Time</th>
								<th>Type</th>
								<th>Status</th>
								<th>Printer</th>
								<th>Details</th>
							</tr>
						</thead>
						<tbody>
							for _, event := range data.RecentEvents {
								<tr>
									<td class="text-nowrap">{ formatEventTime(event.Created) }</td>
									<td><span class="badge bg-secondary">{ event.EventType }</span></td>
									<td>
										if event.Success {
											<span class="text-success">&#10003;</span>
										} else {
											<span class="text-danger">&#10007;</span>
										}
									</td>
									<td>{ event.PrinterName }</td>
									<td class="text-truncate" style="max-width: 300px;" title={ event.Details }>{ event.Details }</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		} else {
			<div class="card-body">
				<p class="text-muted mb-0">No events recorded yet. Events will appear as Bambu operations occur.</p>
			</div>
		}
	</div>
	<!-- Chart.js initialization -->
	<script src="/static/chartjs/chart.umd.min.js"></script>
	<script src="/static/chartjs/chartjs-adapter-date-fns.bundle.min.js"></script>
	<script>
		document.addEventListener('DOMContentLoaded', async function() {
			const canvas = document.getElementById('bambu-metrics-chart');
			if (!canvas) return;

			const seriesConfig = [
				{ name: 'successes', label: 'Successful Polls', color: 'rgb(25, 135, 84)' },
				{ name: 'errors', label: 'Errors', color: 'rgb(220, 53, 69)' },
				{ name: 'api-requests', label: 'Total Requests', color: 'rgb(13, 110, 253)' }
			];

			const datasets = [];
			for (const cfg of seriesConfig) {
				try {
					const resp = await fetch('/admin/bambu-chart?series=' + encodeURIComponent(cfg.name) + '&window=24h');
					const data = await resp.json();
					if (data && data.length > 0) {
						datasets.push({
							label: cfg.label,
							data: data.map(p => ({ x: p.t * 1000, y: p.v })),
							borderColor: cfg.color,
							backgroundColor: cfg.color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
							borderWidth: 2,
							tension: 0.3,
							fill: false,
							pointRadius: 2
						});
					}
				} catch (e) {
					console.error('Failed to fetch', cfg.name, e);
				}
			}

			if (datasets.length === 0) {
				canvas.parentElement.innerHTML = '<p class="text-muted text-center">No metrics data available yet.</p>';
				return;
			}

			new Chart(canvas, {
				type: 'line',
				data: { datasets },
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						x: { type: 'time', time: { unit: 'hour' } },
						y: { beginAtZero: true }
					},
					plugins: {
						legend: { display: true, position: 'top' }
					}
				}
			});
		});
	</script>
}
