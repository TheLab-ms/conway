package admin

import (
	"fmt"
	"strconv"
	"time"
	"github.com/TheLab-ms/conway/modules/bootstrap"
)

func secretPlaceholder(hasValue bool) string {
	if hasValue {
		return "(secret is set - leave blank to keep)"
	}
	return "(not set)"
}

func secretHelpText(hasValue bool) string {
	if hasValue {
		return "Leave blank to keep the current value."
	}
	return ""
}

type configSection struct {
	Name string
	Path string
}

var configSections = []*configSection{
	{Name: "Waiver", Path: "/admin/config/waiver"},
	{Name: "Discord", Path: "/admin/config/discord"},
	{Name: "Stripe", Path: "/admin/config/stripe"},
}

templ renderConfigPage(tabs []*navbarTab, activeSection string, content templ.Component) {
	@bootstrap.View() {
		@adminNav(tabs)
		<div class="container my-5">
			<div class="row">
				<div class="col-md-3">
					<div class="card">
						<div class="card-header">
							<h5 class="mb-0">Configuration</h5>
						</div>
						<div class="list-group list-group-flush">
							for _, section := range configSections {
								if section.Name == activeSection {
									<a href={ templ.SafeURL(section.Path) } class="list-group-item list-group-item-action active">{ section.Name }</a>
								} else {
									<a href={ templ.SafeURL(section.Path) } class="list-group-item list-group-item-action">{ section.Name }</a>
								}
							}
						</div>
					</div>
				</div>
				<div class="col-md-9">
					@content
				</div>
			</div>
		</div>
	}
}

type waiverConfigData struct {
	Version int
	Content string
	Saved   bool
}

templ renderWaiverConfigContent(data *waiverConfigData) {
	<div class="card">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Waiver Content</h5>
			<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Waiver content saved successfully. A new version has been created.
				</div>
			}
			<form method="post">
				<div class="mb-3">
					<label for="content" class="form-label">Waiver Content (Markdown)</label>
					<textarea class="form-control font-monospace" id="content" name="content" rows="20" required>{ data.Content }</textarea>
					<div class="form-text">
						<strong>Syntax:</strong>
						<ul class="mb-0 mt-1">
							<li><code># Title</code> - Sets the page title (first one wins)</li>
							<li>Regular text becomes paragraphs (separate with blank lines)</li>
							<li><code>- [ ] Checkbox text</code> - Creates a required checkbox</li>
						</ul>
					</div>
				</div>
				<div class="d-flex justify-content-between align-items-center">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version.</span>
				</div>
			</form>
		</div>
	</div>
}

type discordConfigData struct {
	Version            int
	ClientID           string
	HasClientSecret    bool
	HasBotToken        bool
	GuildID            string
	RoleID             string
	HasPrintWebhookURL bool
	SyncIntervalHours  int
	Saved              bool
	Error              string

	// Status fields
	TotalLinkedMembers int
	PendingSyncs       int
	RecentEvents       []*discordEvent
}

type discordEvent struct {
	Created       time.Time
	EventType     string
	DiscordUserID string
	Success       bool
	Details       string
	MemberName    string
}

templ renderDiscordConfigContent(data *discordConfigData, selfURL string) {
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Discord Integration</h5>
			if data.Version > 0 {
				<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
			}
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Discord configuration saved successfully.
				</div>
			}
			if data.Error != "" {
				<div class="alert alert-danger" role="alert">
					{ data.Error }
				</div>
			}
			<div class="alert alert-info" role="alert">
				<strong>How Discord Integration Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Account Linking:</strong> Members can link their Discord accounts via OAuth2. This stores their Discord user ID, email, and avatar.</li>
					<li><strong>Role Sync:</strong> A background worker automatically assigns/removes a Discord role based on payment status. Paying members get the role; when payment lapses, it's removed.</li>
					<li><strong>Notifications:</strong> Webhook messages (e.g., 3D printer completion) are sent to configured Discord channels.</li>
				</ul>
			</div>
			<form method="post">
				<h6 class="text-muted border-bottom pb-2 mb-3">OAuth2 Configuration</h6>
				<p class="text-muted small mb-3">
					These settings enable members to link their Discord accounts.
					Create an OAuth2 application at the
					<a href="https://discord.com/developers/applications" target="_blank" rel="noopener">Discord Developer Portal</a>.
					Set the redirect URL to: <code>{ selfURL }/discord/callback</code>
				</p>
				<div class="mb-3">
					<label for="client_id" class="form-label">Client ID</label>
					<input type="text" class="form-control font-monospace" id="client_id" name="client_id" value={ data.ClientID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">The Application ID from Discord Developer Portal.</div>
				</div>
				<div class="mb-3">
					<label for="client_secret" class="form-label">Client Secret</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="client_secret" name="client_secret" placeholder={ secretPlaceholder(data.HasClientSecret) }/>
					</div>
					<div class="form-text">The OAuth2 Client Secret. Keep this confidential. { secretHelpText(data.HasClientSecret) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Bot Configuration</h6>
				<p class="text-muted small mb-3">
					The bot enables Conway to manage Discord roles based on payment status.
					Create a bot in your Discord application and invite it to your server with the <code>Manage Roles</code> permission.
					The bot's role must be positioned <strong>above</strong> the member role in Discord's role hierarchy.
				</p>
				<div class="mb-3">
					<label for="bot_token" class="form-label">Bot Token</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="bot_token" name="bot_token" placeholder={ secretPlaceholder(data.HasBotToken) }/>
					</div>
					<div class="form-text">The bot token from Discord Developer Portal. Required for role sync. { secretHelpText(data.HasBotToken) }</div>
				</div>
				<div class="mb-3">
					<label for="guild_id" class="form-label">Server (Guild) ID</label>
					<input type="text" class="form-control font-monospace" id="guild_id" name="guild_id" value={ data.GuildID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">Right-click your server name in Discord (with Developer Mode enabled) and select "Copy Server ID".</div>
				</div>
				<div class="mb-3">
					<label for="role_id" class="form-label">Member Role ID</label>
					<input type="text" class="form-control font-monospace" id="role_id" name="role_id" value={ data.RoleID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">The role to assign to paying members. Right-click the role in Server Settings &gt; Roles and select "Copy Role ID".</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Notifications</h6>
				<p class="text-muted small mb-3">
					Configure webhooks for Discord notifications.
					Create a webhook in Discord: Channel Settings &gt; Integrations &gt; Webhooks.
				</p>
				<div class="mb-3">
					<label for="print_webhook_url" class="form-label">3D Print Notification Webhook URL</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="print_webhook_url" name="print_webhook_url" placeholder={ secretPlaceholder(data.HasPrintWebhookURL) }/>
					</div>
					<div class="form-text">Webhook URL for 3D printer completion and failure notifications. { secretHelpText(data.HasPrintWebhookURL) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Sync Settings</h6>
				<div class="mb-3">
					<label for="sync_interval_hours" class="form-label">Full Reconciliation Interval (hours)</label>
					<input type="number" class="form-control" id="sync_interval_hours" name="sync_interval_hours" value={ strconv.Itoa(data.SyncIntervalHours) } min="1" max="168"/>
					<div class="form-text">How often to fully reconcile all Discord role assignments. Default: 24 hours.</div>
				</div>
				<div class="d-flex justify-content-between align-items-center mt-4">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version for audit purposes.</span>
				</div>
			</form>
		</div>
	</div>
	<!-- Status Dashboard -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Status</h5>
		</div>
		<div class="card-body">
			<div class="row text-center">
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.TotalLinkedMembers) }</h3>
					<p class="text-muted mb-0">Linked Accounts</p>
				</div>
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.PendingSyncs) }</h3>
					<p class="text-muted mb-0">Pending Syncs</p>
				</div>
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.SyncIntervalHours) }h</h3>
					<p class="text-muted mb-0">Sync Interval</p>
				</div>
			</div>
		</div>
	</div>
	<!-- Metrics Chart -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Request Metrics (Last 24 Hours)</h5>
		</div>
		<div class="card-body">
			<div style="position: relative; height: 280px;">
				<canvas id="discord-metrics-chart"></canvas>
			</div>
			<p class="text-muted small mt-2 mb-0">Events are aggregated in 15-minute intervals. Data retained for 24 hours.</p>
		</div>
	</div>
	<!-- Recent Events -->
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Recent Events</h5>
			<span class="badge bg-secondary">{ strconv.Itoa(len(data.RecentEvents)) }</span>
		</div>
		if len(data.RecentEvents) > 0 {
			<div class="card-body p-0">
				<div class="table-responsive">
					<table class="table table-hover table-sm mb-0">
						<thead class="table-light">
							<tr>
								<th>Time</th>
								<th>Type</th>
								<th>Status</th>
								<th>Member</th>
								<th>Details</th>
							</tr>
						</thead>
						<tbody>
							for _, event := range data.RecentEvents {
								<tr>
									<td class="text-nowrap">{ formatEventTime(event.Created) }</td>
									<td><span class="badge bg-secondary">{ event.EventType }</span></td>
									<td>
										if event.Success {
											<span class="text-success">&#10003;</span>
										} else {
											<span class="text-danger">&#10007;</span>
										}
									</td>
									<td>{ event.MemberName }</td>
									<td class="text-truncate" style="max-width: 300px;" title={ event.Details }>{ event.Details }</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		} else {
			<div class="card-body">
				<p class="text-muted mb-0">No events recorded yet. Events will appear as Discord operations occur.</p>
			</div>
		}
	</div>
	<!-- Chart.js initialization -->
	<script src="/static/chartjs/chart.umd.min.js"></script>
	<script src="/static/chartjs/chartjs-adapter-date-fns.bundle.min.js"></script>
	<script>
		document.addEventListener('DOMContentLoaded', async function() {
			const canvas = document.getElementById('discord-metrics-chart');
			if (!canvas) return;

			const seriesConfig = [
				{ name: 'sync-successes', label: 'Sync Successes', color: 'rgb(25, 135, 84)' },
				{ name: 'sync-errors', label: 'Sync Errors', color: 'rgb(220, 53, 69)' },
				{ name: 'api-requests', label: 'Total Requests', color: 'rgb(13, 110, 253)' }
			];

			const datasets = [];
			for (const cfg of seriesConfig) {
				try {
					const resp = await fetch('/admin/discord-chart?series=' + encodeURIComponent(cfg.name) + '&window=24h');
					const data = await resp.json();
					if (data && data.length > 0) {
						datasets.push({
							label: cfg.label,
							data: data.map(p => ({ x: p.t * 1000, y: p.v })),
							borderColor: cfg.color,
							backgroundColor: cfg.color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
							borderWidth: 2,
							tension: 0.3,
							fill: false,
							pointRadius: 2
						});
					}
				} catch (e) {
					console.error('Failed to fetch', cfg.name, e);
				}
			}

			if (datasets.length === 0) {
				canvas.parentElement.innerHTML = '<p class="text-muted text-center">No metrics data available yet.</p>';
				return;
			}

			new Chart(canvas, {
				type: 'line',
				data: { datasets },
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						x: { type: 'time', time: { unit: 'hour' } },
						y: { beginAtZero: true }
					},
					plugins: {
						legend: { display: true, position: 'top' }
					}
				}
			});
		});
	</script>
}

type stripeConfigData struct {
	Version             int
	HasAPIKey           bool
	HasWebhookKey       bool
	Saved               bool
	Error               string

	// Status fields
	ActiveSubscriptions int
	TotalCustomers      int
	RecentEvents        []*stripeEvent
}

type stripeEvent struct {
	Created          time.Time
	EventType        string
	StripeCustomerID string
	Success          bool
	Details          string
	MemberName       string
}

templ renderStripeConfigContent(data *stripeConfigData, selfURL string) {
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Stripe Integration</h5>
			if data.Version > 0 {
				<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
			}
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Stripe configuration saved successfully.
				</div>
			}
			if data.Error != "" {
				<div class="alert alert-danger" role="alert">
					{ data.Error }
				</div>
			}
			<div class="alert alert-info" role="alert">
				<strong>How Stripe Integration Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Subscriptions:</strong> Members pay for membership via Stripe Checkout. Conway receives webhooks when subscription status changes.</li>
					<li><strong>Billing Portal:</strong> Active members can manage their subscription (update payment method, cancel) via Stripe's billing portal.</li>
					<li><strong>Discounts:</strong> Coupons configured in Stripe with matching <code>discountTypes</code> metadata are automatically applied.</li>
				</ul>
			</div>
			<form method="post">
				<h6 class="text-muted border-bottom pb-2 mb-3">API Configuration</h6>
				<p class="text-muted small mb-3">
					Get your API keys from the
					<a href="https://dashboard.stripe.com/apikeys" target="_blank" rel="noopener">Stripe Dashboard</a>.
					Use test keys for development and live keys for production.
				</p>
				<div class="mb-3">
					<label for="api_key" class="form-label">Secret Key</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="api_key" name="api_key" placeholder={ secretPlaceholder(data.HasAPIKey) }/>
					</div>
					<div class="form-text">The API secret key (starts with <code>sk_test_</code> or <code>sk_live_</code>). { secretHelpText(data.HasAPIKey) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Webhook Configuration</h6>
				<p class="text-muted small mb-3">
					Create a webhook endpoint in the
					<a href="https://dashboard.stripe.com/webhooks" target="_blank" rel="noopener">Stripe Dashboard</a>.
					Set the endpoint URL to: <code>{ selfURL }/webhooks/stripe</code>
					<br/>Subscribe to events: <code>customer.subscription.created</code>, <code>customer.subscription.updated</code>, <code>customer.subscription.deleted</code>
				</p>
				<div class="mb-3">
					<label for="webhook_key" class="form-label">Webhook Signing Secret</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="webhook_key" name="webhook_key" placeholder={ secretPlaceholder(data.HasWebhookKey) }/>
					</div>
					<div class="form-text">The webhook signing secret (starts with <code>whsec_</code>). Used to verify webhook authenticity. { secretHelpText(data.HasWebhookKey) }</div>
				</div>
				<div class="d-flex justify-content-between align-items-center mt-4">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version for audit purposes.</span>
				</div>
			</form>
		</div>
	</div>
	<!-- Status Dashboard -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Status</h5>
		</div>
		<div class="card-body">
			<div class="row text-center">
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.ActiveSubscriptions) }</h3>
					<p class="text-muted mb-0">Active Subscriptions</p>
				</div>
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.TotalCustomers) }</h3>
					<p class="text-muted mb-0">Total Customers</p>
				</div>
			</div>
		</div>
	</div>
	<!-- Metrics Chart -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">API Metrics (Last 24 Hours)</h5>
		</div>
		<div class="card-body">
			<div style="position: relative; height: 280px;">
				<canvas id="stripe-metrics-chart"></canvas>
			</div>
			<p class="text-muted small mt-2 mb-0">Events are aggregated in 15-minute intervals. Data retained for 24 hours.</p>
		</div>
	</div>
	<!-- Recent Events -->
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Recent Events</h5>
			<span class="badge bg-secondary">{ strconv.Itoa(len(data.RecentEvents)) }</span>
		</div>
		if len(data.RecentEvents) > 0 {
			<div class="card-body p-0">
				<div class="table-responsive">
					<table class="table table-hover table-sm mb-0">
						<thead class="table-light">
							<tr>
								<th>Time</th>
								<th>Type</th>
								<th>Status</th>
								<th>Member</th>
								<th>Details</th>
							</tr>
						</thead>
						<tbody>
							for _, event := range data.RecentEvents {
								<tr>
									<td class="text-nowrap">{ formatEventTime(event.Created) }</td>
									<td><span class="badge bg-secondary">{ event.EventType }</span></td>
									<td>
										if event.Success {
											<span class="text-success">&#10003;</span>
										} else {
											<span class="text-danger">&#10007;</span>
										}
									</td>
									<td>{ event.MemberName }</td>
									<td class="text-truncate" style="max-width: 300px;" title={ event.Details }>{ event.Details }</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		} else {
			<div class="card-body">
				<p class="text-muted mb-0">No events recorded yet. Events will appear as Stripe operations occur.</p>
			</div>
		}
	</div>
	<!-- Chart.js initialization -->
	<script src="/static/chartjs/chart.umd.min.js"></script>
	<script src="/static/chartjs/chartjs-adapter-date-fns.bundle.min.js"></script>
	<script>
		document.addEventListener('DOMContentLoaded', async function() {
			const canvas = document.getElementById('stripe-metrics-chart');
			if (!canvas) return;

			const seriesConfig = [
				{ name: 'successes', label: 'Successes', color: 'rgb(25, 135, 84)' },
				{ name: 'errors', label: 'Errors', color: 'rgb(220, 53, 69)' },
				{ name: 'api-requests', label: 'Total Requests', color: 'rgb(13, 110, 253)' }
			];

			const datasets = [];
			for (const cfg of seriesConfig) {
				try {
					const resp = await fetch('/admin/stripe-chart?series=' + encodeURIComponent(cfg.name) + '&window=24h');
					const data = await resp.json();
					if (data && data.length > 0) {
						datasets.push({
							label: cfg.label,
							data: data.map(p => ({ x: p.t * 1000, y: p.v })),
							borderColor: cfg.color,
							backgroundColor: cfg.color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
							borderWidth: 2,
							tension: 0.3,
							fill: false,
							pointRadius: 2
						});
					}
				} catch (e) {
					console.error('Failed to fetch', cfg.name, e);
				}
			}

			if (datasets.length === 0) {
				canvas.parentElement.innerHTML = '<p class="text-muted text-center">No metrics data available yet.</p>';
				return;
			}

			new Chart(canvas, {
				type: 'line',
				data: { datasets },
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						x: { type: 'time', time: { unit: 'hour' } },
						y: { beginAtZero: true }
					},
					plugins: {
						legend: { display: true, position: 'top' }
					}
				}
			});
		});
	</script>
}
