package admin

import (
	"fmt"
	"strconv"
	"time"
	"github.com/TheLab-ms/conway/modules/bootstrap"
)

func secretPlaceholder(hasValue bool) string {
	if hasValue {
		return "(secret is set - leave blank to keep)"
	}
	return "(not set)"
}

func secretHelpText(hasValue bool) string {
	if hasValue {
		return "Leave blank to keep the current value."
	}
	return ""
}

type configSection struct {
	Name string
	Path string
}

var configSections = []*configSection{
	{Name: "Waiver", Path: "/admin/config/waiver"},
	{Name: "Discord", Path: "/admin/config/discord"},
	{Name: "Google Login", Path: "/admin/config/google"},
	{Name: "Stripe", Path: "/admin/config/stripe"},
	{Name: "Bambu", Path: "/admin/config/bambu"},
	{Name: "Fob API", Path: "/admin/config/fobapi"},
	{Name: "OAuth2 Provider", Path: "/admin/config/oauth2"},
}

templ renderConfigPage(tabs []*navbarTab, activeSection string, content templ.Component) {
	@bootstrap.View() {
		@adminNav(tabs)
		<div class="container my-5">
			<div class="row">
				<div class="col-md-3">
					<div class="card">
						<div class="card-header">
							<h5 class="mb-0">Configuration</h5>
						</div>
						<div class="list-group list-group-flush">
							for _, section := range configSections {
								if section.Name == activeSection {
									<a href={ templ.SafeURL(section.Path) } class="list-group-item list-group-item-action active">{ section.Name }</a>
								} else {
									<a href={ templ.SafeURL(section.Path) } class="list-group-item list-group-item-action">{ section.Name }</a>
								}
							}
						</div>
					</div>
				</div>
				<div class="col-md-9">
					@content
				</div>
			</div>
		</div>
	}
}

type waiverConfigData struct {
	Version int
	Content string
	Saved   bool
}

templ renderWaiverConfigContent(data *waiverConfigData) {
	<div class="card">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Waiver Content</h5>
			<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Waiver content saved successfully. A new version has been created.
				</div>
			}
			<form method="post">
				<div class="mb-3">
					<label for="content" class="form-label">Waiver Content (Markdown)</label>
					<textarea class="form-control font-monospace" id="content" name="content" rows="20" required>{ data.Content }</textarea>
					<div class="form-text">
						<strong>Syntax:</strong>
						<ul class="mb-0 mt-1">
							<li><code># Title</code> - Sets the page title (first one wins)</li>
							<li>Regular text becomes paragraphs (separate with blank lines)</li>
							<li><code>- [ ] Checkbox text</code> - Creates a required checkbox</li>
						</ul>
					</div>
				</div>
				<div class="d-flex justify-content-between align-items-center">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version.</span>
				</div>
			</form>
		</div>
	</div>
}

type discordConfigData struct {
	Version            int
	ClientID           string
	HasClientSecret    bool
	HasBotToken        bool
	GuildID            string
	RoleID             string
	HasPrintWebhookURL bool
	SyncIntervalHours  int
	Saved              bool
	Error              string

	// Status fields
	TotalLinkedMembers int
	PendingSyncs       int
	RecentEvents       []*discordEvent
}

type discordEvent struct {
	Created       time.Time
	EventType     string
	DiscordUserID string
	Success       bool
	Details       string
	MemberName    string
}

templ renderDiscordConfigContent(data *discordConfigData, selfURL string) {
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Discord Integration</h5>
			if data.Version > 0 {
				<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
			}
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Discord configuration saved successfully.
				</div>
			}
			if data.Error != "" {
				<div class="alert alert-danger" role="alert">
					{ data.Error }
				</div>
			}
			<div class="alert alert-info" role="alert">
				<strong>How Discord Integration Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Account Linking:</strong> Members can link their Discord accounts via OAuth2. This stores their Discord user ID, email, and avatar.</li>
					<li><strong>Role Sync:</strong> A background worker automatically assigns/removes a Discord role based on payment status. Paying members get the role; when payment lapses, it's removed.</li>
					<li><strong>Notifications:</strong> Webhook messages (e.g., 3D printer completion) are sent to configured Discord channels.</li>
				</ul>
			</div>
			<form method="post">
				<h6 class="text-muted border-bottom pb-2 mb-3">OAuth2 Configuration</h6>
				<p class="text-muted small mb-3">
					These settings enable members to link their Discord accounts.
					Create an OAuth2 application at the
					<a href="https://discord.com/developers/applications" target="_blank" rel="noopener">Discord Developer Portal</a>.
					Set the redirect URL to: <code>{ selfURL }/discord/callback</code>
				</p>
				<div class="mb-3">
					<label for="client_id" class="form-label">Client ID</label>
					<input type="text" class="form-control font-monospace" id="client_id" name="client_id" value={ data.ClientID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">The Application ID from Discord Developer Portal.</div>
				</div>
				<div class="mb-3">
					<label for="client_secret" class="form-label">Client Secret</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="client_secret" name="client_secret" placeholder={ secretPlaceholder(data.HasClientSecret) }/>
					</div>
					<div class="form-text">The OAuth2 Client Secret. Keep this confidential. { secretHelpText(data.HasClientSecret) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Bot Configuration</h6>
				<p class="text-muted small mb-3">
					The bot enables Conway to manage Discord roles based on payment status.
					Create a bot in your Discord application and invite it to your server with the <code>Manage Roles</code> permission.
					The bot's role must be positioned <strong>above</strong> the member role in Discord's role hierarchy.
				</p>
				<div class="mb-3">
					<label for="bot_token" class="form-label">Bot Token</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="bot_token" name="bot_token" placeholder={ secretPlaceholder(data.HasBotToken) }/>
					</div>
					<div class="form-text">The bot token from Discord Developer Portal. Required for role sync. { secretHelpText(data.HasBotToken) }</div>
				</div>
				<div class="mb-3">
					<label for="guild_id" class="form-label">Server (Guild) ID</label>
					<input type="text" class="form-control font-monospace" id="guild_id" name="guild_id" value={ data.GuildID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">Right-click your server name in Discord (with Developer Mode enabled) and select "Copy Server ID".</div>
				</div>
				<div class="mb-3">
					<label for="role_id" class="form-label">Member Role ID</label>
					<input type="text" class="form-control font-monospace" id="role_id" name="role_id" value={ data.RoleID } placeholder="e.g., 123456789012345678"/>
					<div class="form-text">The role to assign to paying members. Right-click the role in Server Settings &gt; Roles and select "Copy Role ID".</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Notifications</h6>
				<p class="text-muted small mb-3">
					Configure webhooks for Discord notifications.
					Create a webhook in Discord: Channel Settings &gt; Integrations &gt; Webhooks.
				</p>
				<div class="mb-3">
					<label for="print_webhook_url" class="form-label">3D Print Notification Webhook URL</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="print_webhook_url" name="print_webhook_url" placeholder={ secretPlaceholder(data.HasPrintWebhookURL) }/>
					</div>
					<div class="form-text">Webhook URL for 3D printer completion and failure notifications. { secretHelpText(data.HasPrintWebhookURL) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Sync Settings</h6>
				<div class="mb-3">
					<label for="sync_interval_hours" class="form-label">Full Reconciliation Interval (hours)</label>
					<input type="number" class="form-control" id="sync_interval_hours" name="sync_interval_hours" value={ strconv.Itoa(data.SyncIntervalHours) } min="1" max="168"/>
					<div class="form-text">How often to fully reconcile all Discord role assignments. Default: 24 hours.</div>
				</div>
				<div class="d-flex justify-content-between align-items-center mt-4">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version for audit purposes.</span>
				</div>
			</form>
		</div>
	</div>
	<!-- Status Dashboard -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Status</h5>
		</div>
		<div class="card-body">
			<div class="row text-center">
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.TotalLinkedMembers) }</h3>
					<p class="text-muted mb-0">Linked Accounts</p>
				</div>
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.PendingSyncs) }</h3>
					<p class="text-muted mb-0">Pending Syncs</p>
				</div>
				<div class="col-md-4">
					<h3 class="mb-0">{ strconv.Itoa(data.SyncIntervalHours) }h</h3>
					<p class="text-muted mb-0">Sync Interval</p>
				</div>
			</div>
		</div>
	</div>
	<!-- Recent Events -->
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Recent Events</h5>
			<span class="badge bg-secondary">{ strconv.Itoa(len(data.RecentEvents)) }</span>
		</div>
		if len(data.RecentEvents) > 0 {
			<div class="card-body p-0">
				<div class="table-responsive">
					<table class="table table-hover table-sm mb-0">
						<thead class="table-light">
							<tr>
								<th>Time</th>
								<th>Type</th>
								<th>Status</th>
								<th>Member</th>
								<th>Details</th>
							</tr>
						</thead>
						<tbody>
							for _, event := range data.RecentEvents {
								<tr>
									<td class="text-nowrap">{ formatEventTime(event.Created) }</td>
									<td><span class="badge bg-secondary">{ event.EventType }</span></td>
									<td>
										if event.Success {
											<span class="text-success">&#10003;</span>
										} else {
											<span class="text-danger">&#10007;</span>
										}
									</td>
									<td>{ event.MemberName }</td>
									<td class="text-truncate" style="max-width: 300px;" title={ event.Details }>{ event.Details }</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		} else {
			<div class="card-body">
				<p class="text-muted mb-0">No events recorded yet. Events will appear as Discord operations occur.</p>
			</div>
		}
	</div>
}

type stripeConfigData struct {
	Version             int
	HasAPIKey           bool
	HasWebhookKey       bool
	Saved               bool
	Error               string

	// Status fields
	ActiveSubscriptions int
	TotalCustomers      int
	RecentEvents        []*stripeEvent
}

type stripeEvent struct {
	Created          time.Time
	EventType        string
	StripeCustomerID string
	Success          bool
	Details          string
	MemberName       string
}

templ renderStripeConfigContent(data *stripeConfigData, selfURL string) {
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Stripe Integration</h5>
			if data.Version > 0 {
				<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
			}
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Stripe configuration saved successfully.
				</div>
			}
			if data.Error != "" {
				<div class="alert alert-danger" role="alert">
					{ data.Error }
				</div>
			}
			<div class="alert alert-info" role="alert">
				<strong>How Stripe Integration Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Subscriptions:</strong> Members pay for membership via Stripe Checkout. Conway receives webhooks when subscription status changes.</li>
					<li><strong>Billing Portal:</strong> Active members can manage their subscription (update payment method, cancel) via Stripe's billing portal.</li>
					<li><strong>Discounts:</strong> Coupons configured in Stripe with matching <code>discountTypes</code> metadata are automatically applied.</li>
				</ul>
			</div>
			<form method="post">
				<h6 class="text-muted border-bottom pb-2 mb-3">API Configuration</h6>
				<p class="text-muted small mb-3">
					Get your API keys from the
					<a href="https://dashboard.stripe.com/apikeys" target="_blank" rel="noopener">Stripe Dashboard</a>.
					Use test keys for development and live keys for production.
				</p>
				<div class="mb-3">
					<label for="api_key" class="form-label">Secret Key</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="api_key" name="api_key" placeholder={ secretPlaceholder(data.HasAPIKey) }/>
					</div>
					<div class="form-text">The API secret key (starts with <code>sk_test_</code> or <code>sk_live_</code>). { secretHelpText(data.HasAPIKey) }</div>
				</div>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Webhook Configuration</h6>
				<p class="text-muted small mb-3">
					Create a webhook endpoint in the
					<a href="https://dashboard.stripe.com/webhooks" target="_blank" rel="noopener">Stripe Dashboard</a>.
					Set the endpoint URL to: <code>{ selfURL }/webhooks/stripe</code>
					<br/>Subscribe to events: <code>customer.subscription.created</code>, <code>customer.subscription.updated</code>, <code>customer.subscription.deleted</code>
				</p>
				<div class="mb-3">
					<label for="webhook_key" class="form-label">Webhook Signing Secret</label>
					<div class="input-group">
						<input type="password" class="form-control font-monospace" id="webhook_key" name="webhook_key" placeholder={ secretPlaceholder(data.HasWebhookKey) }/>
					</div>
					<div class="form-text">The webhook signing secret (starts with <code>whsec_</code>). Used to verify webhook authenticity. { secretHelpText(data.HasWebhookKey) }</div>
				</div>
				<div class="d-flex justify-content-between align-items-center mt-4">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version for audit purposes.</span>
				</div>
			</form>
		</div>
	</div>
	<!-- Status Dashboard -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Status</h5>
		</div>
		<div class="card-body">
			<div class="row text-center">
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.ActiveSubscriptions) }</h3>
					<p class="text-muted mb-0">Active Subscriptions</p>
				</div>
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.TotalCustomers) }</h3>
					<p class="text-muted mb-0">Total Customers</p>
				</div>
			</div>
		</div>
	</div>
	<!-- Recent Events -->
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Recent Events</h5>
			<span class="badge bg-secondary">{ strconv.Itoa(len(data.RecentEvents)) }</span>
		</div>
		if len(data.RecentEvents) > 0 {
			<div class="card-body p-0">
				<div class="table-responsive">
					<table class="table table-hover table-sm mb-0">
						<thead class="table-light">
							<tr>
								<th>Time</th>
								<th>Type</th>
								<th>Status</th>
								<th>Member</th>
								<th>Details</th>
							</tr>
						</thead>
						<tbody>
							for _, event := range data.RecentEvents {
								<tr>
									<td class="text-nowrap">{ formatEventTime(event.Created) }</td>
									<td><span class="badge bg-secondary">{ event.EventType }</span></td>
									<td>
										if event.Success {
											<span class="text-success">&#10003;</span>
										} else {
											<span class="text-danger">&#10007;</span>
										}
									</td>
									<td>{ event.MemberName }</td>
									<td class="text-truncate" style="max-width: 300px;" title={ event.Details }>{ event.Details }</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		} else {
			<div class="card-body">
				<p class="text-muted mb-0">No events recorded yet. Events will appear as Stripe operations occur.</p>
			</div>
		}
	</div>
}

type bambuPrinterFormData struct {
	Index         int
	Name          string
	Host          string
	HasAccessCode bool
	SerialNumber  string
}

type bambuConfigData struct {
	Version          int
	Printers         []*bambuPrinterFormData
	PollIntervalSecs int
	Saved            bool
	Error            string

	// Status fields
	ConfiguredPrinters int
	RecentEvents       []*bambuEvent
}

type bambuEvent struct {
	Created       time.Time
	EventType     string
	PrinterName   string
	PrinterSerial string
	Success       bool
	Details       string
}

templ renderPrinterCard(printer *bambuPrinterFormData, index int) {
	<div class="card mb-3 printer-card" data-printer-index={ strconv.Itoa(index) }>
		<div class="card-header d-flex justify-content-between align-items-center py-2">
			<span class="fw-semibold printer-name-display">
				if printer.Name != "" {
					{ printer.Name }
				} else {
					New Printer
				}
			</span>
			<button type="button" class="btn btn-sm btn-outline-danger delete-printer-btn" onclick="confirmDeletePrinter(this)">
				Delete
			</button>
		</div>
		<div class="card-body">
			<div class="row g-3">
				<div class="col-md-6">
					<label class="form-label">Name</label>
					<input type="text" class="form-control printer-name-input" name={ fmt.Sprintf("printer[%d][name]", index) } value={ printer.Name } placeholder="e.g., Lab Printer 1" required/>
				</div>
				<div class="col-md-6">
					<label class="form-label">Host/IP Address</label>
					<input type="text" class="form-control" name={ fmt.Sprintf("printer[%d][host]", index) } value={ printer.Host } placeholder="e.g., 192.168.1.100" required/>
				</div>
				<div class="col-md-6">
					<label class="form-label">Access Code</label>
					<input type="password" class="form-control font-monospace" name={ fmt.Sprintf("printer[%d][access_code]", index) } placeholder={ secretPlaceholder(printer.HasAccessCode) }/>
					<div class="form-text">{ secretHelpText(printer.HasAccessCode) }</div>
				</div>
				<div class="col-md-6">
					<label class="form-label">Serial Number</label>
					<input type="text" class="form-control font-monospace" name={ fmt.Sprintf("printer[%d][serial_number]", index) } value={ printer.SerialNumber } placeholder="e.g., 01P00A123456789" required/>
				</div>
			</div>
		</div>
		<!-- Delete confirmation (hidden by default) -->
		<div class="card-footer bg-danger-subtle text-danger d-none delete-confirm">
			<span>Are you sure you want to remove this printer?</span>
			<button type="button" class="btn btn-sm btn-danger ms-2" onclick="deletePrinter(this)">
				Confirm Delete
			</button>
			<button type="button" class="btn btn-sm btn-secondary ms-1" onclick="cancelDeletePrinter(this)">
				Cancel
			</button>
		</div>
	</div>
}

templ renderBambuConfigContent(data *bambuConfigData) {
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Bambu 3D Printer Integration</h5>
			if data.Version > 0 {
				<span class="badge bg-secondary">{ fmt.Sprintf("Version %d", data.Version) }</span>
			}
		</div>
		<div class="card-body">
			if data.Saved {
				<div class="alert alert-success" role="alert">
					Bambu configuration saved successfully. Printer connections will be reloaded on next poll.
				</div>
			}
			if data.Error != "" {
				<div class="alert alert-danger" role="alert">
					{ data.Error }
				</div>
			}
			<div class="alert alert-info" role="alert">
				<strong>How Bambu Integration Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Status Monitoring:</strong> Conway polls each Bambu printer via MQTT to display real-time status, progress, and camera feeds.</li>
					<li><strong>Notifications:</strong> Print completion and failure notifications are sent to Discord (configure the webhook URL in Discord settings).</li>
					<li><strong>User Mentions:</strong> Include <code>{ "@username" }</code> in your plate name in Bambu Studio to get mentioned in Discord notifications.</li>
				</ul>
			</div>
			<form method="post" id="bambu-config-form">
				<h6 class="text-muted border-bottom pb-2 mb-3">Printers</h6>
				<p class="text-muted small mb-3">
					Configure your Bambu printers. Each printer needs a name, host (IP address), access code, and serial number.
					Find the access code in Bambu Studio: Printer &gt; Device &gt; Local Connection.
				</p>
				<!-- Printer Cards Container -->
				<div id="printers-container" data-next-index={ strconv.Itoa(len(data.Printers)) }>
					for i, printer := range data.Printers {
						@renderPrinterCard(printer, i)
					}
				</div>
				<!-- Add Printer Button -->
				<button type="button" class="btn btn-outline-primary mb-4" onclick="addPrinter()">
					+ Add Printer
				</button>
				<!-- Hidden template for new printers (JavaScript will clone this) -->
				<template id="printer-card-template">
					@renderPrinterCard(&bambuPrinterFormData{Index: -1}, -1)
				</template>
				<h6 class="text-muted border-bottom pb-2 mb-3 mt-4">Polling Settings</h6>
				<div class="mb-3">
					<label for="poll_interval_seconds" class="form-label">Poll Interval (seconds)</label>
					<input type="number" class="form-control" id="poll_interval_seconds" name="poll_interval_seconds" value={ strconv.Itoa(data.PollIntervalSecs) } min="1" max="60"/>
					<div class="form-text">How often to poll printers for status updates. Default: 5 seconds.</div>
				</div>
				<div class="d-flex justify-content-between align-items-center mt-4">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<span class="text-muted small">Saving creates a new version for audit purposes.</span>
				</div>
			</form>
			<!-- JavaScript for dynamic printer management -->
			<script>
				var printerIndex = parseInt(document.getElementById('printers-container').getAttribute('data-next-index')) || 0;

				function addPrinter() {
					var template = document.getElementById('printer-card-template');
					var clone = template.content.cloneNode(true);
					var card = clone.querySelector('.printer-card');

					// Update the index in data attribute and all input names
					card.setAttribute('data-printer-index', printerIndex);
					card.querySelectorAll('input').forEach(function(input) {
						var name = input.getAttribute('name');
						if (name) {
							input.setAttribute('name', name.replace('[-1]', '[' + printerIndex + ']'));
						}
						// Clear placeholder for access code on new printers
						if (name && name.includes('access_code')) {
							input.setAttribute('placeholder', '(required for new printers)');
						}
					});

					// Add name change listener
					var nameInput = card.querySelector('.printer-name-input');
					if (nameInput) {
						nameInput.addEventListener('input', function() {
							var header = card.querySelector('.card-header .printer-name-display');
							if (header) {
								header.textContent = this.value || 'New Printer';
							}
						});
					}

					document.getElementById('printers-container').appendChild(clone);
					printerIndex++;

					// Focus the first input
					var firstInput = document.getElementById('printers-container').lastElementChild.querySelector('input');
					if (firstInput) {
						firstInput.focus();
					}
				}

				function confirmDeletePrinter(btn) {
					var card = btn.closest('.printer-card');
					var confirmDiv = card.querySelector('.delete-confirm');
					confirmDiv.classList.remove('d-none');
					btn.classList.add('d-none');
				}

				function cancelDeletePrinter(btn) {
					var card = btn.closest('.printer-card');
					var confirmDiv = card.querySelector('.delete-confirm');
					var deleteBtn = card.querySelector('.delete-printer-btn');
					confirmDiv.classList.add('d-none');
					deleteBtn.classList.remove('d-none');
				}

				function deletePrinter(btn) {
					var card = btn.closest('.printer-card');
					card.remove();
				}

				// Update card headers when name changes (for existing printers)
				document.addEventListener('DOMContentLoaded', function() {
					document.querySelectorAll('.printer-name-input').forEach(function(input) {
						input.addEventListener('input', function() {
							var card = this.closest('.printer-card');
							var header = card.querySelector('.card-header .printer-name-display');
							if (header) {
								header.textContent = this.value || 'New Printer';
							}
						});
					});
				});
			</script>
		</div>
	</div>
	<!-- Status Dashboard -->
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Status</h5>
		</div>
		<div class="card-body">
			<div class="row text-center">
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.ConfiguredPrinters) }</h3>
					<p class="text-muted mb-0">Configured Printers</p>
				</div>
				<div class="col-md-6">
					<h3 class="mb-0">{ strconv.Itoa(data.PollIntervalSecs) }s</h3>
					<p class="text-muted mb-0">Poll Interval</p>
				</div>
			</div>
		</div>
	</div>
	<!-- Recent Events -->
	<div class="card mb-4">
		<div class="card-header d-flex justify-content-between align-items-center">
			<h5 class="mb-0">Recent Events</h5>
			<span class="badge bg-secondary">{ strconv.Itoa(len(data.RecentEvents)) }</span>
		</div>
		if len(data.RecentEvents) > 0 {
			<div class="card-body p-0">
				<div class="table-responsive">
					<table class="table table-hover table-sm mb-0">
						<thead class="table-light">
							<tr>
								<th>Time</th>
								<th>Type</th>
								<th>Status</th>
								<th>Printer</th>
								<th>Details</th>
							</tr>
						</thead>
						<tbody>
							for _, event := range data.RecentEvents {
								<tr>
									<td class="text-nowrap">{ formatEventTime(event.Created) }</td>
									<td><span class="badge bg-secondary">{ event.EventType }</span></td>
									<td>
										if event.Success {
											<span class="text-success">&#10003;</span>
										} else {
											<span class="text-danger">&#10007;</span>
										}
									</td>
									<td>{ event.PrinterName }</td>
									<td class="text-truncate" style="max-width: 300px;" title={ event.Details }>{ event.Details }</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		} else {
			<div class="card-body">
				<p class="text-muted mb-0">No events recorded yet. Events will appear as Bambu operations occur.</p>
			</div>
		}
	</div>
}

templ renderFobAPIConfigContent(selfURL string) {
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">Fob API (Access Controllers)</h5>
		</div>
		<div class="card-body">
			<div class="alert alert-info" role="alert">
				<strong>How the Fob API Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Polling:</strong> Access controllers (ESP32 devices) poll this endpoint to get the list of authorized fob IDs.</li>
					<li><strong>Event Logging:</strong> Controllers report fob swipe events back to Conway for audit logging.</li>
					<li><strong>LAN Only:</strong> This endpoint is only accessible from the local network. Internet requests are blocked.</li>
				</ul>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">Endpoint</h6>
			<div class="mb-4">
				<code class="fs-5">POST { selfURL }/api/fobs</code>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">Authentication</h6>
			<p class="text-muted small mb-3">
				No API key is required. Instead, the endpoint uses network-level authentication:
			</p>
			<ul class="mb-4">
				<li>Requests must originate from the <strong>local network</strong></li>
				<li>Requests from the internet are automatically blocked (HTTP 403)</li>
				<li>This is enforced by checking for the <code>CF-Connecting-IP</code> header set by Cloudflare</li>
			</ul>
			<h6 class="text-muted border-bottom pb-2 mb-3">Request Format</h6>
			<p class="text-muted small mb-3">
				Send a JSON array of fob swipe events. This can be an empty array if you just want to fetch the authorized fob list.
			</p>
			<div class="bg-light p-3 rounded mb-3">
				<div class="mb-2">
					<strong class="text-primary">POST</strong> <code>/api/fobs</code>
				</div>
				<div class="mb-2 ps-3 border-start border-2">
					<small class="text-muted d-block">Headers:</small>
					<code>Content-Type: application/json</code><br/>
					<code>If-None-Match: &lt;etag&gt;</code> <span class="text-muted small">(optional, for caching)</span>
				</div>
				<div class="ps-3 border-start border-2">
					<small class="text-muted d-block">Body:</small>
					<pre class="mb-0 bg-white p-2 rounded border"><code>[
  &#123; "fob": 12345678, "allowed": true &#125;,
  &#123; "fob": 87654321, "allowed": false &#125;
]</code></pre>
				</div>
			</div>
			<div class="mb-4">
				<table class="table table-sm">
					<thead class="table-light">
						<tr>
							<th>Field</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><code>fob</code></td>
							<td>integer</td>
							<td>The fob ID that was scanned</td>
						</tr>
						<tr>
							<td><code>allowed</code></td>
							<td>boolean</td>
							<td>Whether access was granted (based on controller's cached list)</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">Response Format</h6>
			<p class="text-muted small mb-3">
				Returns a JSON array of all currently authorized fob IDs, sorted numerically.
			</p>
			<div class="bg-light p-3 rounded mb-3">
				<div class="mb-2">
					<strong class="text-success">HTTP/1.1 200 OK</strong>
				</div>
				<div class="mb-2 ps-3 border-start border-2">
					<small class="text-muted d-block">Headers:</small>
					<code>Content-Type: application/json</code><br/>
					<code>ETag: a1b2c3d4e5f6...</code>
				</div>
				<div class="ps-3 border-start border-2">
					<small class="text-muted d-block">Body:</small>
					<pre class="mb-0 bg-white p-2 rounded border"><code>[12345678, 23456789, 34567890]</code></pre>
				</div>
			</div>
			<div class="mb-4">
				<table class="table table-sm">
					<thead class="table-light">
						<tr>
							<th>Response</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><code>200 OK</code></td>
							<td>Returns JSON array of authorized fob IDs</td>
						</tr>
						<tr>
							<td><code>304 Not Modified</code></td>
							<td>ETag matches; client should use cached list</td>
						</tr>
						<tr>
							<td><code>403 Forbidden</code></td>
							<td>Request originated from the internet (blocked)</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">ETag Caching</h6>
			<p class="text-muted small mb-3">
				The API uses HTTP ETag caching to minimize bandwidth. Controllers should:
			</p>
			<ol class="mb-4">
				<li>Store the <code>ETag</code> header from the response</li>
				<li>Send <code>If-None-Match: &lt;etag&gt;</code> on subsequent requests</li>
				<li>If response is <code>304</code>, continue using the cached fob list</li>
				<li>If response is <code>200</code>, update the cached list and ETag</li>
			</ol>
			<h6 class="text-muted border-bottom pb-2 mb-3">Client Implementation</h6>
			<p class="text-muted small mb-0">
				Reference implementation for ESP32 MicroPython controllers is available in the
				<code>access-controller/</code> directory of the Conway repository.
			</p>
		</div>
	</div>
}

templ renderOAuth2ConfigContent(selfURL string) {
	<div class="card mb-4">
		<div class="card-header">
			<h5 class="mb-0">OAuth2 Provider</h5>
		</div>
		<div class="card-body">
			<div class="alert alert-info" role="alert">
				<strong>How the Built-in OAuth2 Provider Works</strong>
				<ul class="mb-0 mt-2">
					<li><strong>Single Sign-On:</strong> Conway acts as an OAuth2/OpenID Connect provider, allowing other applications on your network to authenticate members using their Conway accounts.</li>
					<li><strong>No Configuration Required:</strong> The OAuth2 provider is always active. There are no secrets or API keys to configure &mdash; any application on the same root domain can integrate.</li>
					<li><strong>Domain Restriction:</strong> Redirect URIs are restricted to the same root domain as Conway. External domains are rejected.</li>
					<li><strong>Standard Protocol:</strong> Implements the standard Authorization Code flow with OpenID Connect Discovery, JWKS, and UserInfo endpoints.</li>
				</ul>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">Discovery</h6>
			<p class="text-muted small mb-3">
				Most OAuth2/OIDC client libraries support automatic discovery. Point your client at the OpenID Configuration URL and it will find all endpoints automatically.
			</p>
			<div class="bg-light p-3 rounded mb-4">
				<div class="mb-2">
					<strong class="text-primary">GET</strong> <code>{ selfURL }/.well-known/openid-configuration</code>
				</div>
				<div class="ps-3 border-start border-2">
					<small class="text-muted d-block">Response:</small>
					<pre class="mb-0 bg-white p-2 rounded border"><code>&#123;
  "issuer": "{ selfURL }",
  "authorization_endpoint": "{ selfURL }/oauth2/authorize",
  "token_endpoint": "{ selfURL }/oauth2/token",
  "userinfo_endpoint": "{ selfURL }/oauth2/userinfo",
  "jwks_uri": "{ selfURL }/oauth2/jwks",
  "id_token_signing_alg_values_supported": ["RS256"]
&#125;</code></pre>
				</div>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">Endpoints</h6>
			<div class="mb-4">
				<table class="table table-sm">
					<thead class="table-light">
						<tr>
							<th>Endpoint</th>
							<th>URL</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><strong>Authorization</strong></td>
							<td><code>{ selfURL }/oauth2/authorize</code></td>
							<td>Redirects the user to Conway login, then back with an authorization code</td>
						</tr>
						<tr>
							<td><strong>Token</strong></td>
							<td><code>{ selfURL }/oauth2/token</code></td>
							<td>Exchanges an authorization code for access and ID tokens</td>
						</tr>
						<tr>
							<td><strong>UserInfo</strong></td>
							<td><code>{ selfURL }/oauth2/userinfo</code></td>
							<td>Returns user profile data for a valid bearer token</td>
						</tr>
						<tr>
							<td><strong>JWKS</strong></td>
							<td><code>{ selfURL }/oauth2/jwks</code></td>
							<td>Public keys for verifying JWT signatures (RS256)</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">Authorization Code Flow</h6>
			<p class="text-muted small mb-3">
				Conway implements the standard OAuth2 Authorization Code flow. Here is the step-by-step process:
			</p>
			<ol class="mb-4">
				<li>
					<strong>Redirect to authorize:</strong> Your application redirects the user to the authorization endpoint with a <code>redirect_uri</code> and optional <code>state</code> parameter.
					<div class="bg-light p-2 rounded mt-1 mb-2">
						<code>GET { selfURL }/oauth2/authorize?redirect_uri=https://app.example.com/callback&amp;state=random123</code>
					</div>
				</li>
				<li><strong>User logs in:</strong> If not already authenticated, Conway prompts the user to log in.</li>
				<li>
					<strong>Callback with code:</strong> Conway redirects back to your <code>redirect_uri</code> with a short-lived <code>code</code> and the <code>state</code>.
					<div class="bg-light p-2 rounded mt-1 mb-2">
						<code>https://app.example.com/callback?code=eyJhbG...&amp;state=random123</code>
					</div>
				</li>
				<li>
					<strong>Exchange code for token:</strong> Your server exchanges the code for tokens using the token endpoint. Authenticate with HTTP Basic Auth using your <code>client_id</code> (any string except <code>"conway"</code>) as the username.
					<div class="bg-light p-2 rounded mt-1 mb-2">
						<code>POST { selfURL }/oauth2/token</code><br/>
						<code>Authorization: Basic base64(client_id:)</code><br/>
						<code>Content-Type: application/x-www-form-urlencoded</code><br/>
						<code>code=eyJhbG...</code>
					</div>
				</li>
				<li><strong>Use the token:</strong> The response includes an <code>access_token</code> and <code>id_token</code> (both JWTs). Use the access token to call the UserInfo endpoint or verify it locally using the JWKS keys.</li>
			</ol>
			<h6 class="text-muted border-bottom pb-2 mb-3">Token Response</h6>
			<p class="text-muted small mb-3">
				The token endpoint returns a JSON response with both an access token and ID token.
			</p>
			<div class="bg-light p-3 rounded mb-3">
				<div class="mb-2">
					<strong class="text-success">HTTP/1.1 200 OK</strong>
				</div>
				<div class="ps-3 border-start border-2">
					<small class="text-muted d-block">Body:</small>
					<pre class="mb-0 bg-white p-2 rounded border"><code>&#123;
  "id_token": "eyJhbGciOiJSUzI1NiIs...",
  "access_token": "eyJhbGciOiJSUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 28800
&#125;</code></pre>
				</div>
			</div>
			<div class="mb-4">
				<table class="table table-sm">
					<thead class="table-light">
						<tr>
							<th>Field</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><code>id_token</code></td>
							<td>JWT containing the member's numeric ID as the <code>sub</code> claim and the <code>client_id</code> as the audience</td>
						</tr>
						<tr>
							<td><code>access_token</code></td>
							<td>Same JWT; use as a Bearer token to call the UserInfo endpoint</td>
						</tr>
						<tr>
							<td><code>token_type</code></td>
							<td>Always <code>"Bearer"</code></td>
						</tr>
						<tr>
							<td><code>expires_in</code></td>
							<td>Token validity in seconds (8 hours)</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">UserInfo Response</h6>
			<p class="text-muted small mb-3">
				Call the UserInfo endpoint with a valid bearer token to get the member's profile.
			</p>
			<div class="bg-light p-3 rounded mb-3">
				<div class="mb-2">
					<strong class="text-primary">GET</strong> <code>{ selfURL }/oauth2/userinfo</code>
				</div>
				<div class="mb-2 ps-3 border-start border-2">
					<small class="text-muted d-block">Headers:</small>
					<code>Authorization: Bearer eyJhbGciOiJSUzI1NiIs...</code>
				</div>
				<div class="ps-3 border-start border-2">
					<small class="text-muted d-block">Response:</small>
					<pre class="mb-0 bg-white p-2 rounded border"><code>&#123;
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "name": "Jane Doe",
  "email": "jane@example.com",
  "groups": ["member", "admin"]
&#125;</code></pre>
				</div>
			</div>
			<div class="mb-4">
				<table class="table table-sm">
					<thead class="table-light">
						<tr>
							<th>Field</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><code>id</code></td>
							<td>string</td>
							<td>A stable UUID derived from the member's internal ID</td>
						</tr>
						<tr>
							<td><code>name</code></td>
							<td>string</td>
							<td>The member's display name</td>
						</tr>
						<tr>
							<td><code>email</code></td>
							<td>string</td>
							<td>The member's email address</td>
						</tr>
						<tr>
							<td><code>groups</code></td>
							<td>array</td>
							<td>Group memberships: <code>"member"</code> (active subscription) and/or <code>"admin"</code> (leadership)</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">Client Configuration</h6>
			<p class="text-muted small mb-3">
				When configuring an OAuth2/OIDC client application to use Conway, use these settings:
			</p>
			<div class="mb-4">
				<table class="table table-sm">
					<thead class="table-light">
						<tr>
							<th>Setting</th>
							<th>Value</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><strong>Issuer / Provider URL</strong></td>
							<td><code>{ selfURL }</code></td>
						</tr>
						<tr>
							<td><strong>Client ID</strong></td>
							<td>Any string that identifies your app (e.g., <code>"wiki"</code>, <code>"gitea"</code>). Must not be <code>"conway"</code>.</td>
						</tr>
						<tr>
							<td><strong>Client Secret</strong></td>
							<td>Not required (pass empty string or any value for Basic Auth)</td>
						</tr>
						<tr>
							<td><strong>Redirect URI</strong></td>
							<td>Must be on the same root domain as Conway</td>
						</tr>
						<tr>
							<td><strong>Scopes</strong></td>
							<td><code>openid</code> (standard; Conway returns full profile regardless)</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h6 class="text-muted border-bottom pb-2 mb-3">Important Notes</h6>
			<ul class="mb-0">
				<li>The <code>client_id</code> <code>"conway"</code> is reserved for internal use and will be rejected by the token endpoint.</li>
				<li>Authorization codes expire after <strong>1 minute</strong>. Exchange them promptly.</li>
				<li>Access tokens are valid for <strong>8 hours</strong>.</li>
				<li>Tokens are signed with RS256. Use the JWKS endpoint to get the public key for local verification.</li>
				<li>The <code>sub</code> claim in the JWT is the member's numeric ID (as a string). The UserInfo endpoint returns a UUID representation of this ID.</li>
			</ul>
		</div>
	</div>
}
